-- Generating code for different combinations Direct/Indirect + Max/Min heap and running test after that
-- Simply run 'lua gen.lua' it will generate all 4 combinations of heaps

local function genname( maxheap, indirect )
	return (indirect and 'Indirect' or '') .. 'Binary' .. (maxheap and 'Max' or 'Min') .. 'Heap'
end

local function gencode( maxheap, indirect )
local code = ([[
-- Generated by gen.lua, don't edit by hand!
-- ${comment}
-- Coded by Ilya Kolbin (iskolbin@gmail.com)

local floor, setmetatable = math.floor, setmetatable

local function siftup( items, priorities, from${indices} )
	local index = from
	local parentIndex = floor( 0.5 * index )
	while index > 1 and priorities[parentIndex] ${compare} priorities[index] do
		priorities[index], priorities[parentIndex] = priorities[parentIndex], priorities[index]
		items[index], items[parentIndex] = items[parentIndex], items[index]
		${swapindices index parentIndex}
		index = parentIndex
		parentIndex = floor( 0.5 * index )
	end
	return index
end

local function siftdown( items, priorities, size, limit${indices} )
	for index = limit, 1, -1 do
		local leftIndex = index + index
		local rightIndex = leftIndex + 1
		while leftIndex <= size do
			local smallerChild = leftIndex
			if rightIndex <= size and priorities[leftIndex] ${compare} priorities[rightIndex] then
				smallerChild = rightIndex
			end
				
			if priorities[index] ${compare} priorities[smallerChild] then
				items[index], items[smallerChild] = items[smallerChild], items[index]
				priorities[index], priorities[smallerChild] = priorities[smallerChild], priorities[index]
				${swapindices index smallerChild}
			else
				break
			end
				
			index = smallerChild
			leftIndex = index + index
			rightIndex = leftIndex + 1
		end
	end
end

local ${name}Mt

local ${name} = {}

function ${name}.new( iparray_ )
	local self = setmetatable( {
		_items = {},
		_priorities = {},
		_size = 0,
	}, ${name}Mt )
	${initindices}

	if iparray_ then
		self:batchenq( iparray_ )
	end
	
	return self
end

function ${name}:enqueue( item, priority )
	local items, priorities${indices} = self._items, self._priorities${selfindices}
	${assertnotcontain indices item}
	local size = self._size + 1
	self._size = size	
	items[size], priorities[size] = item, priority
	siftup( items, priorities, size${indices} ) 
	return self
end

]]..((not indirect) and [[
local function indexof( items, item )
	for i = 1, #items do
		if items[i] == item then
			return i
		end
	end
end

]] or '')..[[
function ${name}:remove( item )
	local index = ${getindex}
	if index ~= nil then
		local size = self._size
		local items, priorities${indices} = self._items, self._priorities${selfindices}
		${updateindex item nil}
		if size == index then
			items[size], priorities[size] = nil, nil
			self._size = size - 1
		else
			local lastitem = items[size]
			items[index], priorities[index] = items[size], priorities[size]
			items[size], priorities[size] = nil, nil
			${updateindex lastitem index}
			size = size - 1
			self._size = size
			if size > 1 then
				local siftedindex = siftup( items, priorities, index${indices} )
				siftdown( items, priorities, size, siftedindex${indices} ) 
			end
		end
		return true
	else
		return false
	end
end

function ${name}:contains( item )
	return ${getindex} ~= nil
end

function ${name}:update( item, priority )
	local ok = self:remove( item )
	if ok then
		self:enqueue( item, priority )
		return true
	else
		return false
	end
end

function ${name}:dequeue()
	local size = self._size
	
	assert( size > 0, 'Heap is empty' )
	
	local items, priorities${indices} = self._items, self._priorities${selfindices}
	local item = items[1]
	${updateindex item nil}

	if size > 1 then
		local newitem = items[size]
		items[1], priorities[1] = newitem, priorities[size]
		items[size], priorities[size] = nil, nil
		${updateindex newitem 1}
		size = size - 1
		self._size = size
		siftdown( items, priorities, size, 1${indices} )
	else
		items[1], priorities[1] = nil, nil
		self._size = 0
	end

	return item
end

function ${name}:peek()
	return self._items[1]
end
	
function ${name}:len()
	return self._size
end

function ${name}:empty()
	return self._size <= 0
end

function ${name}:batchenq( iparray )
	local items, priorities${indices} = self._items, self._priorities${selfindices}
	local size = self._size
	for i = 1, #iparray, 2 do
		local item, priority = iparray[i], iparray[i+1]
		${assertnotcontain indices item}
		size = size + 1
		items[size], priorities[size] = item, priority
		${updateindex item size}
	end
	self._size = size
	if size > 1 then
		siftdown( items, priorities, size, floor( 0.5 * size )${indices} )
	end
end

${name}Mt = {
	__index = ${name},
	__len = ${name}.len,
}
      
return setmetatable( ${name}, {
	__call = function( _, ... )
		return ${name}.new( ... )
	end
} )]])
	:gsub( '%${(%w+)}', {
		comment = (indirect and 'Indirect' or 'Direct') .. ' binary ' .. (maxheap and 'max' or 'min') .. ' heap', 
		name = genname(maxheap,indirect), 
		compare = maxheap and '<' or '>',
		indices = (indirect and ', indices' or ''),
		selfindices = (indirect and ', self._indices' or ''),
		initindices = (indirect and 'self._indices = {}' or ''),
		getindex = (indirect and 'self._indices[item]' or 'indexof( self._items, item )'),
	})

	:gsub( '%${(%w+) (%w+) (%w+)}', function(f, arg1, arg2)
		if f == 'swapindices' then
			return indirect and ('indices[items[%s]], indices[items[%s]] = %s, %s'):format( arg1, arg2, arg1, arg2 ) or ''
		elseif f == 'assertnotcontain' then
			return indirect and ('if %s[%s] ~= nil then error( \'Item \' .. tostring(%s[%s]) .. \' is already in the heap\' ) end'):format( arg1, arg2, arg1, arg2 ) or '' 
		elseif f == 'updateindex' then
			return indirect and ('indices[%s] = %s'):format( arg1, arg2 ) or ''
		end
	end)
	
	return code
end

local function writefile(maxheap,indirect)
	local filename = genname(maxheap,indirect) ..'.lua'
	local f = io.open( filename, 'w+' )
	f:write(gencode(maxheap,indirect))
	f:flush()
	f:close()
end

writefile( false, false )
writefile( true, false )
writefile( false, true )
writefile( true, true )

os.execute'lua test.lua'

